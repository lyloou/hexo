---
title: Android图片裁剪和上传服务器（含：拍照、图库选取）
date: 2018-08-04 09:16:15
toc: true
comments: true
tags:
- linux
---
## 使用
```java
mContext.startActivity(new Intent(mContext, CropImageActivity.class));
```

## 权限声明
```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.FLASHLIGHT" />
```

## 注册Activity
```xml
<activity
    android:name=".CropImageActivity"
    android:screenOrientation="portrait"
    android:theme="@style/myTransparent" />
```

## 透明的theme
```xml

<style name="myTransparent" parent="@android:style/Theme.DeviceDefault.Light.NoActionBar.Fullscreen">
    <item name="android:windowBackground">@color/transparent</item>
    <item name="android:windowNoTitle">true</item>
    <item name="android:windowIsTranslucent">true</item>
    <item name="android:windowAnimationStyle">@android:style/Animation.Translucent</item>
</style>

```


```java
// [Android 拍照，从图库选择照片，并裁剪，上传到服务器 - 简书](https://www.jianshu.com/p/bfd9fe0592cb)
// [拍照/从相册读取图片后进行裁剪的方法 - developer_Kale - 博客园](http://www.cnblogs.com/tianzhijiexian/p/3989296.html)

public class CropImageActivity extends Activity {
    private static final String TAG = CropImageActivity.class.getSimpleName();
    public static final int REQUEST_CODE_CAPTURE = 0x12;
    public static final int REQUEST_CODE_PICKER = 0x13;
    public static final int REQUEST_CODE_CROP = 0x14;
    public static final String TMP_DIR = Environment.getExternalStorageDirectory() + "/lyloou/tmp";
    private int width;
    private int height;
    private File file;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState == null) {
            File tmpDir = new File(TMP_DIR);
            if (!tmpDir.exists()) {
                tmpDir.mkdirs();
            }
            file = new File(tmpDir.getAbsolutePath() + "/icon.png");
            file.delete();

            showDialog();
        }
    }

    private void showDialog() {
        Intent intent = getIntent();
        width = intent.getIntExtra("width", 0);
        height = intent.getIntExtra("height", 0);
        if (width == 0) {
            width = 350;
        }
        if (height == 0) {
            height = 350;
        }

        new AlertDialog.Builder(this)
                .setTitle("更换头像")
                .setItems(new String[]{"拍照", "从相册选择",}, (dialog, which) -> {
                    switch (which) {
                        case 0://拍照
                            Intent intent12 = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                            intent12.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));
                            startActivityForResult(intent12, REQUEST_CODE_CAPTURE);
                            break;
                        case 1://从相册选择
                            Intent intent1 = new Intent(Intent.ACTION_GET_CONTENT);
                            intent1.setType("image/*");
                            startActivityForResult(intent1, REQUEST_CODE_PICKER);
                            break;
                    }
                })
                .setOnCancelListener(dialog -> finish())
                .create()
                .show();
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode != REQUEST_CODE_CAPTURE && data == null) {
            finish();
            return;
        }

        Bundle bundle;
        Bitmap bitmap;
        Uri uri;
        switch (requestCode) {
            case REQUEST_CODE_CAPTURE:     // 从相机跳回来
                if (!file.exists()) {
                    backWithError("拍照异常");
                    return;
                }
                // 启动裁剪器
                startImageZoom(Uri.fromFile(file));
                break;
            case REQUEST_CODE_PICKER:     // 从图库跳回来
                // 此处的uri 是content类型的。 还有一种是file 型的。应该转换为后者
                uri = data.getData();
                if (uri == null) {
                    backWithError("图片无效");
                    return;
                }
                // 记住： 要转化为file类型的uri
                uri = convertUri(uri);
                if (uri == null) {
                    backWithError("图片转换失败");
                    return;
                }
                // 启动裁剪
                startImageZoom(uri);
                break;
            case REQUEST_CODE_CROP:     // 从裁剪处跳回来
                bundle = data.getExtras();
                if (bundle == null) {
                    backWithError("裁剪异常");
                    return;
                }
                bitmap = bundle.getParcelable("data");
                // 方法1
                uri = saveBitmap(bitmap);
                if (uri == null) {
                    backWithError("裁剪失败");
                    return;
                }
                sentImage(uri.getPath());
                break;
        }
    }

    private void sentImage(String path) {
        UokHttp.init().postFile(new ICallBack() {
            @Override
            public String getUrl() {
                return APP_URL + "/user_center/person/edit_avatar";
            }

            @Override
            public void doResponse(JSONObject responseInfo) {
                backWithSuccess(responseInfo);
            }

            @Override
            public void doError(String errorMsg) {
                backWithError(errorMsg);
            }
        }, path);
    }

    private void backWithSuccess(JSONObject responseInfo) {
        // TODO
        // do something with responseInfo
        finish();
    }

    private void backWithError(String errorMsg) {
        // TODO
        // do something with errorMsg
        finish();
    }

    /**
     * 保存经过Base64编码的图片到服务器
     *
     * @param bitmap 待上传的bitmap格式图片
     */
    private void sentImage(Bitmap bitmap) {
        // 先创建 字节数组流： ByteArrayOutputStream: 可以捕获内存缓冲区的数据，转换成字节数组。
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        // 写入一个压缩版的位图到指定的输出流 （这里是字节数组流）
        bitmap.compress(Bitmap.CompressFormat.PNG, 60, stream);
        // 把 字节数组流作为字节数组返回
        byte[] bytes = stream.toByteArray();
        // 用base64 编码方式把一个字节数组编码后以一个新的字节数组返回
        String img = new String(Base64.encode(bytes, Base64.DEFAULT));
        Log.d(TAG, "sentImage: ");
        Log.d(TAG, img);

        String oneBaseDecoder = new String(Base64.decode(img, Base64.DEFAULT));
        Log.d(TAG, "sentImage: ==============");
        Log.d(TAG, "oneBaseDecoder: ");
        Log.d(TAG, oneBaseDecoder);
        /**
         * 接下来就可以 通过http 上传 img 上去服务器了
         */

    }

    /**
     * 把 Bitmap 保存在SD卡路径后，返回file 类型的 uri
     *
     * @param bm
     * @return
     */
    private Uri saveBitmap(Bitmap bm) {
        if (bm == null) {
            return null;
        }

        try {
            FileOutputStream fos = new FileOutputStream(file);
            bm.compress(Bitmap.CompressFormat.PNG, 100, fos);
            fos.flush();
            fos.close();
            return Uri.fromFile(file);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 通过 file 类型的 uri 去启动系统图片裁剪器
     *
     * @param uri
     */
    private void startImageZoom(Uri uri) {
        // 打开裁剪器
        Intent intent = new Intent("com.android.camera.action.CROP");
        // 设置 裁剪的数据uri 和类型 image
        intent.setDataAndType(uri, "image/*");
        // 是可裁剪的
        intent.putExtra("crop", true);
        // 设置裁剪宽高的比例 1：1
        intent.putExtra("aspectX", 1);
        intent.putExtra("aspectY", 1);
        // 设置最终裁剪出来的图片的宽高
        intent.putExtra("outputX", width);
        intent.putExtra("outputY", height);
        // 设置 最终裁剪完是通过intent 传回来的
        intent.putExtra("return-data", true);
        startActivityForResult(intent, REQUEST_CODE_CROP);
    }

    /**
     * 把 content 类型的uri 转换为 file 类型的 uri （其实，就是通过content类型的uri
     * 解释为bitmap，然后保存在sd卡中，通过保存路径来获得file类型额uri）
     *
     * @param uri
     * @return
     */
    private Uri convertUri(Uri uri) {
        try {
            InputStream is = getContentResolver().openInputStream(uri);
            if (is == null) {
                return null;
            }

            Bitmap bitmap = BitmapFactory.decodeStream(is);
            is.close();
            return saveBitmap(bitmap);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```